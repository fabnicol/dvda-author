<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0067)http://www-mmsp.ece.mcgill.ca/documents/audioformats/wave/wave.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<title>Wave File Specifications</title>

<link rel="stylesheet" type="text/css" href="./Wave File Specifications_files/MMSP.css">
<style type="text/css">
table {
		border-top: 2px solid #336699;
		border-bottom: 1px solid #336699;
		border-collapse: collapse;
}
th {
		font-weight: bold;
		border-bottom: 2px solid #336699;
		padding: 5px;
}
td {
		border: 0px;
		padding: 5px;
}
code {
		font-family: courier, monospace;
		color: #008000;
}
var {
		font-family: courier, monospace;
		font-style: normal;
		color: #0000FF;
}
.DIcon {
		width: 16px;
		height: 16px;
		position: relative;
		bottom: -3px;
}
</style>

</head>

<body>

<h1>Audio File Format Specifications</h1>

<p><b>File Description</b>: WAVE or RIFF WAVE sound file<br>
<b>File Extension</b>: Commonly <var>.wav</var>, sometimes <var>.wave</var><br>
<b>File Byte Order</b>: Little-endian</p>

<p><a href="http://www.mcgill.ca/directory/staff/?LastName=kabal&amp;FirstName=peter">
Prof. Peter Kabal</a>, MMSP Lab, ECE, McGill University: Last update:
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2015-04-14<!--webbot bot="Timestamp" endspan i-checksum="12263" --></p>

<h2>WAVE Specifications</h2>

<p>The WAVE file specifications came from Microsoft. The WAVE file format use 
RIFF chunks, each chunk consisting of a chunk identifier, chunk length and chunk 
data.</p>
<ul>
  <li>WAVE specifications, Version 1.0, 1991-08:
    <a href="http://www.seanet.com/Users/matts/riffmci/riffmci.rtf">riffmci.rtf</a><br>
    Local copy:
    <img class="DIcon" src="./Wave File Specifications_files/F-pdf-S.gif">
    <a href="http://www-mmsp.ece.mcgill.ca/documents/audioformats/wave/Docs/riffmci.pdf">Multimedia Programming Interface and Data 
  Specifications 1.0</a>
    (see pages 56-65)</li>
  <li>WAVE update (Revision: 3.0), 1994-04-15:
    <a href="http://support.microsoft.com/support/kb/articles/Q120/2/53.asp">
    Multimedia Registration Kit Revision 3.0 (Q120253)</a>)<br>
    Local copy:
    <img class="DIcon" src="./Wave File Specifications_files/F-pdf-S.gif">
    <a href="http://www-mmsp.ece.mcgill.ca/documents/audioformats/wave/Docs/RIFFNEW.pdf">New Multimedia Data Types and Data Techniques</a> 
  (see pages 12-22)</li>
  <li>Multi-channel / high bit resolution formats, 2001-12-04:
    <a href="http://www.microsoft.com/whdc/device/audio/multichaud.mspx">
  Multiple Channel Audio Data and WAVE Files</a><br>
    Local copy:
    <img class="DIcon" src="./Wave File Specifications_files/F-pdf-S.gif">
    <a href="http://www-mmsp.ece.mcgill.ca/documents/audioformats/wave/Docs/multichaudP.pdf">Multiple Channel Audio Data and WAVE Files</a></li>
</ul>

<h2>Data Types</h2>

<p>The data in WAVE files can be of many different types. Data format codes are 
listed in the following:</p>
<ul>
  <li>Internet RFC, Codec registrations, 1998-06:
    <img class="DIcon" src="./Wave File Specifications_files/document-S.gif">
    <a href="ftp://ftp.isi.edu/in-notes/rfc2361.txt">
    ftp://ftp.isi.edu/in-notes/rfc2361.txt</a><br>
    Local copy:
    <img class="DIcon" src="./Wave File Specifications_files/document-S.gif">
    <a href="http://www-mmsp.ece.mcgill.ca/documents/audioformats/wave/Docs/rfc2361.txt">rfc2361.txt</a></li>
  <li>Microsoft include files (part of the MSVC compiler or the <i>DirectX SDK</i>: 
  from <a href="http://www.microsoft.com/downloads/search.asp">Microsoft 
  Download Center</a>)<br>
    Local copy:
    <img class="DIcon" src="./Wave File Specifications_files/F-h-S.gif">
    <a href="http://www-mmsp.ece.mcgill.ca/documents/audioformats/wave/Docs/MMREG.H">MMREG.H</a> (Version 1.46)<br>
    Local copy:
    <img class="DIcon" src="./Wave File Specifications_files/F-h-S.gif">
    <a href="http://www-mmsp.ece.mcgill.ca/documents/audioformats/wave/Docs/ksmedia.h">ksmedia.h</a></li>
</ul>

<h2>Wave File Format</h2>

<p>Wave files have a master RIFF chunk which includes a WAVE identifier followed 
by sub-chunks. The data is stored in little-endian byte order.</p>
<table width="340px">
  <colgroup>
    <col width="5%">
    <col width="5%">
    <col width="16%">
  </colgroup>
  <tbody><tr>
    <th colspan="2">Field</th>
    <th>Length</th>
    <th>Contents</th>
  </tr>
  <tr>
    <td colspan="2"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>RIFF</code></q></td>
  </tr>
  <tr>
    <td colspan="2"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: <code>4+<i>n</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td><code>WAVEID</code></td>
    <td>4</td>
    <td>WAVE ID: <q><code>WAVE</code></q></td>
  </tr>
  <tr>
    <td></td>
    <td>WAVE chunks</td>
    <td><code><i>n</i></code></td>
    <td>Wave chunks containing format information and sampled data</td>
  </tr>
</tbody></table>
<p></p>

<h2>fmt Chunk</h2>

<p>The <code>fmt</code> specifies the format of the data. There are 3 variants 
of the Format chunk for sampled data. These differ in the extensions to the 
basic <code>fmt</code> chunk.</p>
<table width="480px">
  <colgroup>
    <col width="3%">
    <col width="15%">
    <col width="5%">
    <col width="16%">
  </colgroup>
  <tbody><tr>
    <th colspan="2">Field</th>
    <th>Length</th>
    <th>Contents</th>
  </tr>
  <tr>
    <td colspan="2"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>fmt </code></q></td>
  </tr>
  <tr>
    <td colspan="2"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: 16, 18 or 40</td>
  </tr>
  <tr>
    <td></td>
    <td><code>wFormatTag</code></td>
    <td>2</td>
    <td>Format code</td>
  </tr>
  <tr>
    <td></td>
    <td><code>nChannels</code></td>
    <td>2</td>
    <td>Number of interleaved channels</td>
  </tr>
  <tr>
    <td></td>
    <td><code>nSamplesPerSec</code></td>
    <td>4</td>
    <td>Sampling rate (blocks per second)</td>
  </tr>
  <tr>
  <td></td>
    <td><code>nAvgBytesPerSec</code></td>
    <td>4</td>
    <td>Data rate</td>
  </tr>
  <tr>
  <td></td>
    <td><code>nBlockAlign</code></td>
    <td>2</td>
    <td>Data block size (bytes)</td>
  </tr>
  <tr>
  <td></td>
    <td><code>wBitsPerSample</code></td>
    <td>2</td>
    <td>Bits per sample</td>
  </tr>
  <tr>
    <td></td>
    <td><code>cbSize</code></td>
    <td>2</td>
    <td>Size of the extension (0 or 22)</td>
  </tr>
  <tr>
    <td></td>
    <td><code>wValidBitsPerSample</code></td>
    <td>2</td>
    <td>Number of valid bits</td>
  </tr>
  <tr>
    <td></td>
    <td><code>dwChannelMask</code></td>
    <td>4</td>
    <td>Speaker position mask</td>
  </tr>
  <tr>
    <td></td>
    <td><code>SubFormat</code></td>
    <td>16</td>
    <td>GUID, including the data format code</td>
  </tr>
</tbody></table>
<p></p>

<p>The standard format codes for waveform data are given below. The references 
above give more format codes for compressed data, a good fraction of which are 
now obsolete.</p>
<table width="449px">
  <colgroup>
    <col width="16%">
    <col width="42%">
  </colgroup>
  <tbody><tr>
    <th>Format Code</th>
    <th>PreProcessor Symbol</th>
    <th>Data</th>
  </tr>
  <tr>
    <td><code>0x0001</code></td>
    <td><code>WAVE_FORMAT_PCM</code></td>
    <td>PCM</td>
  </tr>
  <tr>
    <td><code>0x0003</code></td>
    <td><code>WAVE_FORMAT_IEEE_FLOAT</code></td>
    <td>IEEE float</td>
  </tr>
  <tr>
    <td><code>0x0006</code></td>
    <td><code>WAVE_FORMAT_ALAW</code></td>
    <td>8-bit ITU-T G.711 A-law</td>
  </tr>
  <tr>
    <td><code>0x0007</code></td>
    <td><code>WAVE_FORMAT_MULAW</code></td>
    <td>8-bit ITU-T G.711 µ-law</td>
  </tr>
  <tr>
    <td><code>0xFFFE</code></td>
    <td><code>WAVE_FORMAT_EXTENSIBLE</code></td>
    <td>Determined by <code>SubFormat</code></td>
  </tr>
</tbody></table>
<p></p>

<h3>PCM Format</h3>

<p>The first part of the Format chunk is used to describe PCM data.</p>
<ul>
  <li>For PCM data, the Format chunk in the header declares the number of 
    bits/sample in each sample (<code>wBitsPerSample</code>). The original 
    documentation (Revision 1) specified that the number of bits per sample is to 
    be rounded up to the next multiple of 8 bits. This rounded-up value is the 
    container size. This information is redundant in that the container size (in 
    bytes) for each sample can also be determined from the block size divided by 
    the number of channels (<code>nBlockAlign</code>  / <code>nChannels</code>).
    <ul>
      <li>This redundancy has been appropriated to define new formats. For instance,
        <i>Cool Edit</i> uses a format which declares a sample size of 24 bits together 
          with a container size of 4 bytes (32 bits) determined from the block size and 
          number of channels. With this combination, the data is actually stored as 
          32-bit IEEE floats. The normalization (full scale 2<sup>23</sup>) is however 
          different from the standard float format.</li>
    </ul>
  </li>
  <li>PCM data is two's-complement except for resolutions of 1-8 bits, which are 
    represented as offset binary.</li>
</ul>

<h3>Non-PCM Formats</h3>

<p>An extended Format chunk is used for non-PCM data. The
<code>cbSize</code> field gives the size of the extension.</p>
<ul>
  <li>For all formats other than PCM, the Format chunk <em>must</em> have an 
    extended portion. The extension can be of zero length, but the size field 
    (with value 0) must be present.</li>
  <li>For float data, full scale is 1. The bits/sample would normally be 32 or 64.</li>
  <li>For the log-PCM formats (µ-law and A-law), the Rev. 3 documentation 
    indicates that the bits/sample field (<code>wBitsPerSample</code>) should be 
    set to 8 bits.</li>
  <li>The non-PCM formats must have a <code>fact</code> chunk.</li>
</ul>

<h3>Extensible Format</h3>

<p>The <code>WAVE_FORMAT_EXTENSIBLE</code> format code indicates that there is 
an extension to the Format chunk. The extension has one field which declares the 
number of <q>valid</q> bits/sample (<code>wValidBitsPerSample</code>). Another 
field (<code>dwChannelMask</code>) contains bits which indicate the mapping from 
channels to loudspeaker positions. The last field (<code>SubFormat</code>) is a 
16-byte globally unique identifier (GUID).</p>
<ul>
  <li>With the <code>WAVE_FORMAT_EXTENSIBLE</code> format, the original 
    bits/sample field (<code>wBitsPerSample</code>) must match the container size 
    (<code>8 * nBlockAlign / nChannels</code>). This means that <code>
    wBitsPerSample</code> must be a multiple of 8. Reduced precision within the 
    container size is now specified by
    <code>wValidBitsPerSample</code>.</li>
  <li>The number of valid bits (<code>wValidBitsPerSample</code>) is 
    informational only. The data is correctly represented in the precision of the 
    container size. The number of valid bits can be any value from 1 to the 
    container size in bits.</li>
  <li>The loudspeaker position mask uses 18 bits, each bit corresponding to a 
    speaker position (e.g. Front Left or Top Back Right), to indicate the channel 
    to speaker mapping. More details are in the document cited above. This field 
    is informational. An all-zero field indicates that channels are mapped to 
    outputs in order: first channel to first output, second channel to second 
    output, etc.</li>
  <li>The first two bytes of the GUID form the sub-code specifying the data 
    format code, e.g. <code>WAVE_FORMAT_PCM</code>. The remaining 14 bytes contain 
    a fixed string,
    <q><code>\x00\x00\x00\x00\x10\x00\x80\x00\x00\xAA\x00\x38\x9B\x71</code></q>.</li>
</ul>
<p>The <code>WAVE_FORMAT_EXTENSIBLE</code> format should be used whenever:</p>
<ul>
  <li>PCM data has more than 16 bits/sample.</li>
  <li>The number of channels is more than 2.</li>
  <li>The actual number of bits/sample is not equal to the container size.</li>
  <li>The mapping from channels to speakers needs to be specified.</li>
</ul>

<h2>fact Chunk</h2>

<p>All (compressed) non-PCM formats <em>must</em> have a <code>fact</code> chunk 
(Rev. 3 documentation). The chunk contains at least one value, the number of 
samples in the file.</p>
<table width="420px">
  <colgroup>
    <col width="5%">
    <col width="22%">
    <col width="14%">
  </colgroup>
  <tbody><tr>
    <th colspan="2">Field</th>
    <th>Length</th>
    <th>Contents</th>
  </tr>
  <tr>
    <td colspan="2"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>fact</code></q></td>
  </tr>
  <tr>
    <td colspan="2"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: minimum 4</td>
  </tr>
  <tr>
    <td></td>
    <td><code>dwSampleLength</code></td>
    <td>4</td>
    <td>Number of samples (per channel)</td>
  </tr>
</tbody></table>

<ul>
  <li>The Rev. 3 documentation states that the Fact chunk <q>is required for all 
    new new WAVE formats</q>, but <q>is not required</q> for the standard
    <code>WAVE_FORMAT_PCM</code> file. One presumes that files with IEEE float 
    data (introduced after the Rev. 3 documention) need a <code>fact</code> chunk.</li>
  <li>The number of samples field is redundant for sampled data, since the Data 
    chunk indicates the length of the data. The number of samples can be 
    determined from the length of the data and the container size as determined 
    from the Format chunk.</li>
  <li>There is an ambiguity as to the meaning of <q>number of samples</q> for 
    multichannel data. The implication in the Rev. 3 documentation is that it 
    should be interpreted to be <q>number of samples per channel</q>. The 
    statement in the Rev. 3 documentation is:

    <blockquote>The <code>nSamplesPerSec</code> field from the wave format 
		header is used in conjunction with the <code>dwSampleLength</code> field 
		to determine the length of the data in seconds.</blockquote>

    With no mention of the number of channels in this computation, this implies 
    that <code>dwSampleLength</code> is the number of samples per channel.</li>
  <li>There is a question as to whether the <code>fact</code> chunk should be 
    used for (including those with PCM) <code>WAVE_FORMAT_EXTENSIBLE</code> 
    files. One example of a <code>WAVE_FORMAT_EXTENSIBLE</code> 
    with PCM data from Microsoft, does not have a <code>fact</code> chunk.</li>
</ul>

<h2>data Chunk</h2>

<p>The <code>data</code> chunk contains the sampled data.</p>
<table width="320px">
  <colgroup>
    <col width="5%">
    <col width="31%">
    <col width="14%">
  </colgroup>

  <tbody><tr>
    <th colspan="2">Field</th>
    <th>Length</th>
    <th>Contents</th>
  </tr>
  <tr>
    <td colspan="2"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>data</code></q></td>
  </tr>
  <tr>
    <td colspan="2"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: <code><i>n</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>sampled data</td>
    <td><code><i>n</i></code></td>
    <td>Samples</td>
  </tr>
  <tr>
    <td></td>
    <td>pad byte</td>
    <td>0 or 1</td>
    <td>Padding byte if <code><i>n</i></code> is odd</td>
  </tr>
</tbody></table>
<p></p>

<h2>Examples</h2>

<p>Consider sampled data with the following parameters,</p>
<ul>
  <li><code><i>N<sub>c</sub></i></code> channels</li>
  <li>The total number of blocks is <code><i>N<sub>s</sub></i></code>. Each 
    block consists of <code><i>N<sub>c</sub></i></code> 
    samples.</li>
  <li>Sampling rate <code><i>F</i></code> (blocks per second)</li>
  <li>Each sample is <code><i>M</i></code> bytes long</li>
</ul>

<h3>PCM Data</h3>

<table width="472px">
  <colgroup>
    <col width="5%">
    <col width="5%">
    <col width="24%">
    <col width="18%">
  </colgroup>
  <tbody><tr>
    <th colspan="3">Field</th>
    <th>Length</th>
    <th>Contents</th>
  </tr>
  <tr>
    <td colspan="3"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>RIFF</code></q></td>
  </tr>
  <tr>
    <td colspan="3"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: <code>4 + 24 + (8 + <i>M*N<sub>c</sub>*N<sub>s</sub></i> + 
	(0 or 1)</code></td>
  </tr>
  <tr>
    <td></td>
    <td colspan="2"><code>WAVEID</code></td>
    <td>4</td>
    <td>WAVE ID: <q><code>WAVE</code></q></td>
  </tr>
  <tr>
    <td></td>
    <td colspan="2"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>fmt </code></q></td>
  </tr>
  <tr>
    <td></td>
    <td colspan="2"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: 16</td>
  </tr>
  <tr>
    <td></td>
	<td></td>
    <td><code>wFormatTag</code></td>
    <td>2</td>
    <td><code>WAVE_FORMAT_PCM</code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>nChannels</code></td>
    <td>2</td>
    <td><code><i>N<sub>c</sub></i></code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>nSamplesPerSec</code></td>
    <td>4</td>
    <td><code><i>F</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td><code>nAvgBytesPerSec</code></td>
    <td>4</td>
    <td><code><i>F*M*N<sub>c</sub></i></code></td>
  </tr>
  <tr>
    <td></td>
  	<td></td>
    <td><code>nBlockAlign</code></td>
    <td>2</td>
    <td><code><i>M*N<sub>c</sub></i></code></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td><code>wBitsPerSample</code></td>
    <td>2</td>
    <td>rounds up to <code>8*<i>M</i></code></td>
  </tr>
  <tr>
  	<td></td>
    <td colspan="2"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>data</code></q></td>
  </tr>
  <tr>
  	<td></td>
    <td colspan="2"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: <code><i>M*N<sub>c</sub>*N<sub><sub>s</sub></sub></i></code></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>sampled data</td>
    <td><code><i>M*N<sub>c</sub>*N<sub>s</sub></i></code></td>
    <td><code><i>N<sub>c</sub>*N<sub>s</sub></i></code> channel-interleaved 
    <code><i>M</i></code>-byte samples</td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td>pad byte</td>
    <td>0 or 1</td>
    <td>Padding byte if <code><i>M*N<sub>c</sub>*N<sub>s</sub></i></code> is odd</td>
  </tr>
</tbody></table>
<p></p>

<h4><i>Notes</i></h4>

<ul>
  <li>WAVE files often have information chunks that precede or follow the sound 
  data (<code>data</code> chunk). Some programs (naively) assume that for PCM 
  data, the preamble in the file header is exactly 44 bytes long (as in the 
  table above) and that the rest of the file contains sound data. This is not a 
  safe assumption.</li>
</ul>

<h3>Non-PCM Data</h3>

<table width="470px">
  <colgroup>
    <col width="5%">
    <col width="5%">
    <col width="30%">
    <col width="14%">
  </colgroup>
  <tbody><tr>
    <th colspan="3">Field</th>
    <th>Length</th>
    <th>Contents</th>
  </tr>
  <tr>
    <td colspan="3"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>RIFF</code></q></td>
  </tr>
  <tr>
    <td colspan="3"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: <code>4 + 26 + 12 + (8 + <i>M*N<sub>c</sub>*N<sub>s</sub></i> 
	+ (0 or 1))</code></td>
  </tr>
  <tr>
    <td></td>
    <td colspan="2"><code>WAVEID</code></td>
    <td>4</td>
    <td>WAVE ID: <q><code>WAVE</code></q></td>
  </tr>
  <tr>
  	<td></td>
    <td colspan="2"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>fmt </code></q>;</td>
  </tr>
  <tr>
    <td></td>
    <td colspan="2"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: 18</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td><code>wFormatTag</code></td>
    <td>2</td>
    <td>Format code</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td><code>nChannels</code></td>
    <td>2</td>
    <td><code><i>N<sub>c</sub></i></code></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td><code>nSamplesPerSec</code></td>
    <td>4</td>
    <td><code><i>F</i></code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>nAvgBytesPerSec</code></td>
    <td>4</td>
    <td><code><i>F*M*N<sub>c</sub></i></code></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td><code>nBlockAlign</code></td>
    <td>2</td>
    <td><code><i>M*N<sub>c</sub></i></code></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td><code>wBitsPerSample</code></td>
    <td>2</td>
    <td><code>8*<i>M</i></code> (float data) or <code>16</code> (log-PCM data)</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td><code>cbSize</code></td>
    <td>2</td>
    <td>Size of the extension: 0</td>
  </tr>
  <tr>
    <td colspan="3"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>fact</code></q></td>
  </tr>
  <tr>
    <td colspan="3"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: 4</td>
  </tr>
  <tr>
    <td></td>
    <td colspan="2"><code>dwSampleLength</code></td>
    <td>4</td>
    <td><code><i>N<sub>c</sub>*N<sub>s</sub></i></code></td>
  </tr>
  <tr>
    <td colspan="3"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>data</code></q></td>
  </tr>
  <tr>
    <td colspan="3"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: 
      <code><i>M*N<sub>c</sub>*N<sub>s</sub></i></code></td>
  </tr>
  <tr>
    <td></td>
    <td colspan="2">sampled data</td>
    <td><code><i>M*N<sub>c</sub>*N<sub>s</sub></i></code></td>
    <td><code><i>N<sub>c</sub>*N<sub>s</sub></i></code> channel-interleaved 
      <code><i>M</i></code>-byte samples</td>
  </tr>
  <tr>
    <td></td>
    <td colspan="2">pad byte</td>
    <td>0 or 1</td>
    <td>Padding byte if 
      <code><i>M*N<sub>c</sub>*N<sub>s</sub></i></code> is odd</td>
  </tr>
</tbody></table>

<ul>
  <li>Microsoft <i>Windows Media Player</i> will not play non-PCM data (e.g. 
  µ-law data) if the <code>fmt</code> chunk does not have the extension size 
  field (<code>cbSize</code>) or a <code>fact</code> chunk is not present.</li>
</ul>

<h3>Extensible Format</h3>

<table width="470px">
  <colgroup>
    <col width="5%">
    <col width="5%">
    <col width="30%">
  </colgroup>
  <tbody><tr>
    <th colspan="3">Field</th>
    <th>Length</th>
    <th>Contents</th>
  </tr>
  <tr>
    <td colspan="3"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>RIFF</code></q></td>
  </tr>
  <tr>
    <td colspan="3"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: 
      <code>4 + 48 + 12 + (8 + <i>M*N<sub>c</sub>*N<sub>s</sub></i> + (0 </code>
      or <code>1</code>)</td>
  </tr>
  <tr>
    <td></td>
    <td colspan="2"><code>WAVEID</code></td>
    <td>4</td>
    <td>WAVE ID: <q><code>WAVE</code></q></td>
  </tr>
  <tr>
  	<td></td>
    <td colspan="2"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>fmt </code></q></td>
  </tr>
  <tr>
  	<td></td>
    <td colspan="2"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: 40</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td><code>wFormatTag</code></td>
    <td>2</td>
    <td><code>WAVE_FORMAT_EXTENSIBLE</code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>nChannels</code></td>
    <td>2</td>
    <td><code><i>N<sub>c</sub></i></code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>nSamplesPerSec</code></td>
    <td>4</td>
    <td><code><i>F</i></code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>nAvgBytesPerSec</code></td>
    <td>4</td>
    <td><code><i>F</i> * <i>M*N<sub>c</sub></i></code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>nBlockAlign</code></td>
    <td>2</td>
    <td><code><i>M*N<sub>c</sub></i></code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>wBitsPerSample</code></td>
    <td>2</td>
    <td><code>8 * <i>M</i></code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>cbSize</code></td>
    <td>2</td>
    <td>Size of the extension: 22</td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>wValidBitsPerSample</code></td>
    <td>2</td>
    <td>at most <code>8*<i>M</i></code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>dwChannelMask</code></td>
    <td>4</td>
    <td>Speaker position mask</td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td><code>SubFormat</code></td>
    <td>16</td>
    <td>GUID (first two bytes are the data format code)</td>
  </tr>
  <tr>
  	<td></td>
    <td colspan="2"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>fact</code></q></td>
  </tr>
  <tr>
  	<td></td>
    <td colspan="2"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: 4</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td><code>dwSampleLength</code></td>
    <td>4</td>
    <td><code><i>N<sub>c</sub>*N<sub>s</sub></i></code></td>
  </tr>
  <tr>
  <td></td>
    <td colspan="2"><code>ckID</code></td>
    <td>4</td>
    <td>Chunk ID: <q><code>data</code></q></td>
  </tr>
  <tr>
  	<td></td>
    <td colspan="2"><code>cksize</code></td>
    <td>4</td>
    <td>Chunk size: 
      <code><i>M*N<sub>c</sub>*N<sub>s</sub></i></code></td>
  </tr>
  <tr>
  	<td></td>
  	<td></td>
    <td>sampled data</td>
    <td><code><i>M*N<sub>c</sub>*N<sub>s</sub></i></code></td>
    <td><code><i>N<sub>c</sub>*N<sub>s</sub></i></code> channel-interleaved 
      <code><i>M</i></code>-byte samples</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>pad byte</td>
    <td>0 or 1</td>
    <td>Padding byte if <code><i>M*N<sub>c</sub>*N<sub>s</sub></i></code>
       is odd</td>
  </tr>
</tbody></table>

<ul>
  <li>The <code>fact</code> chunk can normally be omitted if the sampled data is 
  in PCM format.</li>
  <li>In some cases, Microsoft <i>Windows Media Player</i> enforces the use of 
  the
    <code>WAVE_FORMAT_EXTENSIBLE</code> format code. For instance a file with 
  24-bit data declared as a standard
    <code>FORMAT_PCM</code> format code will not play, but a file with 24-bit 
  data declared as a <code>WAVE_FORMAT_EXTENSIBLE</code>
    file with a <code> WAVE_FORMAT_PCM</code> subcode can be played.</li>
</ul>

<hr>

<h4><a href="http://www-mmsp.ece.mcgill.ca/documents/audioformats/wave/Samples.html">Sample Wave Files</a></h4>




</body></html>